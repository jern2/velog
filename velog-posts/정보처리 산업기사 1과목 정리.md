<p>• 커널
    • 운영체계의 가장 중요한 핵심 부분
    • 운영체제의 다른 모든 부분에 다양하고 기본적인 서비스를 제공하는 역할
운영체제의 주요 자원 관리 기능
    • 프로세스 관리, 기억장치 관리, 주변장치 관리, 파일 관리
운영체제의 목적(p.20)
• 처리능력(Throughput)
• 반환 시간(Turn Around Time)
• 사용 가능도(Availability)
• 신뢰도(Reliability)
운영체제의 성능 판단 요소
• 처리 능력, 반환 시간, 신뢰도, 이용 가능도, 병목 현상
Windows의 주요 특징 (p.23)
• GUI, 선점형 멀티테스킹, OLE, PnP, Single-User 시스템(컴퓨터 한 대를 한 사람만이 독점해서 사용)
• 선점형 멀티태스킹 : 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
• PnP(Plug and Play) : 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능
• OLE(Object Linking and Embedding) : 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능
UNIX의 주요 특징(p.25)
• 시분할 시스템(Time Sharing System) 을 위해 설계된 대화식 운영체제, 소스가 공개된 개방형 시스템
• 이식성이 높음(because C언어), 호환성 높음
• 크기 작고 이해 easy
• 다중 사용자, 다중 작업 지원
• 많은 네트워킹 기능 제공, 통신망 관리용 운영체제로 적합
• 트리 구조의 파일 시스템
쉘 : 명령어 해석, 사용자 인터페이스!!!!!! / 명령어가 포함된 파일 형태로 존재, 보조 기억장치에서 교체 처리 가능
커널 : UNIX의 핵심적인 부분 / 주기억장치에 적재
UNIX 시스템 구성
• 사용자&gt;유틸리티&gt;쉘&gt;커널&gt;하드웨어
UNIX에서 프로세스 간 통신
• 시그널 : 간단한 메시지를 이용하여 통신하는 것
• 파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식
• 소켓 : 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식(프로세스 간 통신 위해 사용)
시스템 호출 : 프로세스가 커널에 접근하기 위한 인터페이스를 제공하는 명령어
UNIX 파일 시스템의 구조 (p.27)
• 부트 블록 : 부팅 시 필요한 코드를 저장하고 있는 블록
• 슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록
• I-node 블록(Index node) : 각 파일이나 디렉터리에 대한 모든 정보를 저장하고 있는 블록
• 정보 : 파일 소유자의 사용자 번호 및 그룹 번호, 파일 크기, 파일 타입, 생성 시기, 최종 변경 시기, 최근 사용 시기, 파일 보호 권한, 파일 링크 수, 데이터가 저장된 블록의 시작 주소
• 데이터 블록 : 디렉터리별로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록
• IP주소
• 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
• 숫자로 8비트씩 4부분, 총 32비트
• A Class
• 국가나 대형 통신망에 사용
B Class
• 중대형 통신망에 사용
C Class
• 소규모 통신망에 사용
D Class
• 멀티캐스트 용으로 사용
E Class
• 실험적 주소, 공용 x
서브네팅(p.33)
• 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용
• 서브넷 마스크 : 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트
IPv6
• 128비트
• 패킷 크기 확장 o / 패킷 크기 제한 x
• 자동으로 네트워크 환경 구성 가능
• 16비트 8부분, 총 128비트
• 각 부분 16진수 표현, :으로 구분
• IPv6 주소 체계
• 유니캐스트 : 단일 송신자 단일 수신자(1:1 통신)
• 멀티캐스트 : 단일 송신자와 다중 수신자(1:다 통신)
• 애니캐스트 : 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1:1 통신)
도메인 네임
• 왼쪽 → 오른쪽 상위 도멩ㄴ
• 도메인 네임 → IP 주소 : DNS 서버
프로토콜 데이터 단위
• 물리 계층 : 비트
• 데이터 링크 계층 : 프레임
• 네트워크 계층 : 패킷
• 전송 계층 : 세그먼트
• 세션, 표현, 응용 계층 : 메시지
데이터 링크 계층
• 흐름 제어
• 프레임 동기화
• 오류 제어
• 순서 제어
네트워크 관련 장비(P.40)
• 브리지 : 두 개의 LAN이 데이터 링크 계층에서 서로 결합되어 있는 경우 이들을 연결하는 요소
• 게이트웨이 : 서로 다른 프로토콜을 사용하는 망을 연결
• 인터네트워킹 장비 : 디지털 신호 전송에 사용되는 장비
• 브리지, 라우터, 게이트웨이
각 장비가 동작하는 위치
• 데이터 링크 계층 : 브리지
• 네트워크 계층 : 라우터
• 세션 계층, 표현 계층, 응용 계층 : 게이트웨이
리피터 : 신호 재생
브리지 : 동종 LAN 연결
라우터 : 서로 다른 LAN 연결, 경로 설정 및 전송
모뎀 : 디지털 데이터 → 아날로그 신호로 변환 / 신호 변환 장치
프로토콜(p.43)
• 구문 : 전송하고자 하는 데이터 형식, 부호화, 신호 레벨 규정
• 의미 : 협조 사항과 오류 관리를 위한 제어 정보 규정
• 시간 : 두 기기 간의 통신 속도, 메시지 순서 제어
캡슐화에 사용되는 제어 정보 세 가지
• 주소, 오류 검출 코드, 프로토콜 제어
두 매체 간에 통신 속도 조정, 메시지 전송 및 순서 : 타이밍
TCP/IP(p.45)
• 구조
인터넷 계층의 주요 프로토콜
• ARP : IP 주소 → 물리적 주소
• RARP : 물리적 주소 → IP 주소
유닉스에서 프로세스 구성 요소
• 코드 영역, 자료 영역, 스택 영역, 사용자 영역
UNIX 파일 시스템 구조
• 부트 블록 : 부팅 시 필요한 코드 저장
• 슈퍼 블록 : 전체 파일 시스템에 대한 정보 저장
• I-node 블록 : 각 파일, 디렉터리에 대한 모든 정보 저장, 파일 소유자의 사용자 번호 및 그룹 번호, 파일 크기, 파일 type, 생성 시기, 최종 변경 시기, 최근 사용 시기, 파일의 보호 권한, 파일 링크 수, 데이터가 저장된 블록의 시작 주소 등이 저장되어 있음
• 데이터 블록 : 디렉터리별로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록
소프트웨어 생명 주기(p.59)
• 폭포수 모형
• 이전 단계로 돌아갈 수 없다는 전제 하에 각 단계를 매듭짓고 결과 검토 후 승인 과정 거친 후 다음 단계 진행
• 고전적 생명 주기 모형이라고 함.
• 선형 순차적 모형 : 한 단계가 끝나야만 다음 단계로 넘어갈 수 있음.
• 메뉴얼 작성해야함.
• 병행 x
• 타당성 검토 → 계획 → 요구 분석 → 설계 → 구현(코딩) → 시험(검사) → 유지보수
프로토타입 모형
• 견본품을 만들어 최종 결과물 예측
• 사용자와 시스템 사이 인터페이스에 중점 두어 개발
• 소프트웨어 개발 완료된 시점에서 오류가 발견되는 폭포수 단점 보완 모형
• 요구 수집 → 빠른 설계 → 프로토 타입 구축 → 고객 평가 → 프로토 타입 조정 → 구현 이 사이클 계속 반복
나선형 모델
• 보헴이 제안
• 점진적 모형이라고도 함.
• 유지보수 과정 필요 x
애자일 모형
• 스프린트, 이터레이션이라고 불리는 짧은 개발 주기 반복
• 반복되는 주기마다 만들어지는 결과물에 대한 고객 평가, 요구 적극 수용
소프트웨어 개발 방법론(p.64)
• 구조적 방법론
• 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론
• 분할과 정복 원리 적용
• 절차
• 타당성 검토 단계 → 계획 단계 → 요구사항 단계 → 설계 단계 → 구현 단계 <strong>**→ 시험 단계 → 운용/유지보수 단계
정보공학 방법론
• 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심 방법론
• 절차
• 정보 전략 계획 수립 단계 → 업무 영역 분석 단계 → 업무 시스템 설계 단계 → 업무 시스템 구축 단계
객체지향 방법론
• 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책
• 요구 분석 단계 → 설계 단계 → 구현 단계 → 테스트 및 검증 → 인도 단계
컴포넌트 기반 방법론
• 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
• 재사용 가능 → 시간, 노력 절감
• 확장성 보장
• 유지 보수 비용 최소화, 생산성 및 품질 향상 가능
• 절차
• 개발 준비 단계 → 분석 단계 → 설계 단계 → 구현 단계 → 테스트 단계 → 전개 단계 → 인도 단계
애자일 방법론
• 종류
• 익스트림 프로그래밍, 스크럼, 칸반, 크리스탈
• 절차
• 사용자 스토리 → (계획 → 개발 → 승인 테스트) : () 주기 반복
제품 계열 방법론
• 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
• 임베디드 소프트웨어 만드는데 적합
스크럼
• 제품 책임자
• 백로그 작성
• 우선순위 지정
스크럼 마스터
• 조언을 해주는 가이드 역할 수행
개발팀
제품백로그
• 모든 요구사항을 우선순위에 따라 나열한 목록
• 지속적으로 업데이트됨.
• 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획 수립
스프린트 계획 회의
• 단기 일정을 수립
스프린트
• 실제 개발 작업 진행
• 할 일, 진행 중, 완료 상태를 가짐.
일일 스크럼 회의
스프린트 검토 회의
• 부분 또는 전체 완성 제품이 요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅 수행
• 한 주당 한 시간 내에서 진행
스프린트 회고
• 정해놓은 규칙을 잘 준수했는지, 개선할 점은 없는지 등을 확인하고 기록함.
XP 기법(p.71)
• 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
• 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것 목적
• 핵심 가치
• 의사소통, 단순성, 용기, 존중, 피드백
스파이크
• 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
이터레이션
승인 검사
소규모 릴리즈
요구사항 정의
• 기능 요구사항
• 무엇을 하는지, 어떤 기능을 하는지
• 반드시 수행해야 하는 기능
• 제공받기 원하는 기능
비기능 요구사항
• 가용성
• 사용하고자 할 때 언제라도 사용할 수 있는 정도
정합성
• 데이터의 값이 서로 모순 없이 일관되게 일치하는 정도
상호 호환성
• 다른 소프트웨어와 정보를 교환할 수 있는 정도
대응성
• 발생한 상황에 대처하는 정도
이식성
• 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 정도
확장성
• 규모나 범위를 넓힐 수 있는 정도
요구사항 개발 프로세스
• 도출 → 분석 → 명세 → 확인
요구사항 분석
• 구조적 분석 기법
• 자료 흐름도(버블 차트)
• 구조적 분석 기법
자료 사전(메타 데이터)
• 자료 흐름도에 있는 자료를 더 자세히 정의해 기록한 것
소단위 명세서(프로세스 명세서)
• 자료 흐름도 상의 최하위 처리 절차를 상세하게 기술하는 데 사용하는 도구
• 구조적 언어, 의사 결정표(판단표), 의사 결정도를 이요하여 기술함
개체 관계도 (ERD)
• 시스템에서 처리되는 개체(자료)와 개체의 구성과 속성, 개체 간의 관계를 표현하여 개체를 모델화하는 도구
• 개체, 관계, 속성
상태 전이도(STD, State Transition Diagram)
• 시스템에 어떤 일이 발생할 경우 시스템의 상태와 상태의 변화를 모델링하는 것
• , 제어 명세서
요구사항 분석 CASE와 HIPO
• SADT(Structured Analysis and Design Technique)
• 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구
SREM(Software Requirements Engineering Methodology) = RSL/REVS
• TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것, RSL과 REVS를 사용하는 자동화 도구이다.
• RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어
• REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기
• PSL/PSA : PSL과 PSA를 사용하는 자동화 도구
• PSL : 문제(요구사항) 기술 언어
• PSA : PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기
TAGS(Technology for Automated Generation of Systems) : 시스템 공학 방법 응용에 대한 자동 접근 방법, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구
HIPO(Hierarchy Input Process Output) : 시스템의 분석 및 설계나 문서화할 때 사용되는 기법, 시스템 실행 과정인 입력, 처리, 출력 기능 - 하향식!
• 기본 시스템 모델 : 입력, 처리, 출력
• 하향식 소프트웨어 개발을 위한 문서화 도구
• 유지보수 용이, 기능과 자료의 의존 관계 동시 표현 o
• HIPO Chart 종류</strong>(가→ 총 → 세)**
• 가시적 도표(도식 목차, Visual Table of Contents) : 시스템 전체적인 기능과 흐름을 보여주는 계층 구조도
• 총체적 도표(총괄도표, 개요 도표, Overview Diagram) : 프로그램 구성하는 기능을 기술한 것, 입력,처리,출력에 대한 전반적인 정보 제공 도표
• 세부적 도표(상세 도표, Detail Diagram) : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술 도표
UML(Unified Modeling Language) (p.87) (사물 관계 다이어그램!)
• 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
• 사물
• 모델 구성하는 가장 중요한 요소
• 다이어그램 안에서 관계가 형성될 수 있는 대상
관계
• 사물과 사물 사이의 연관성
• 일반화 관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
• 실체화 관계 : 사물이 할 수 있거나 해야 하는 기능(오퍼레이션, 인터페이스)으로 서로를 그룹화 할 수 있는 관계 표현
다이어그램
• 사물과 관계를 도형으로 표현한 것
• 정적 모델링 : 구조적 다이어그램 사용<strong>(클객컴배복패)</strong>
• 클래스 다이어그램
• 시스템의 구조 파악 o , 구조상 문제점 도출 o
• 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
• 시스템 모델링, 시스템 구성 요소 문서화하는 데 사용
객체 다이어그램 : 럼바우 객체지향 분석 기법에서 객체 모델링에 활용
컴포넌트 다이어그램 : 구현 단계에서 사용
배치 다이어그램 : 노드와 의사소통(통신) 경로로 표현, 구현 단계에서 사용
복합체 구조 다이어그램
패키지 다이어그램 : 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계 표현
동적 모델링 : 행위 다이어그램 사용<strong>(유시커상활상타)</strong>
• 유스케이스 다이어그램
• 사용자와 사용 사례로 구성, 사용 사례 간에 여러 형태의 관계로 이루어짐.
시퀀스 다이어그램
• 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
• 시스템, 객체들의 상호 작용 과정에서 주고받는 메시지 표현
• 각 동작에 참여하는 시스템이나 객체들의 수행 기간 확인 o
• 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호작용 표현
• 액터(Actor), 객체(Object), 생명선(Lifeline), 실행 상자(Active Box), 메시지(Message)
커뮤니케이션 다이어그램 : 메시지 뿐 아니라 객체들 간의 연관까지 표현
상태 다이어그램 : 럼바우 객체지향 분석 기법에서 동적 모델링에 활용
활동 다이어그램 : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
상호작용 개요 다이어그램
타이밍 다이어그램 : 객체 상태 변화와 시간 제약을 명시적으로 표현
소프트웨어 아키텍쳐(p.96)
• 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 작성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
• 모듈화 : 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
• 추상화 : 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것<strong>(제과데)</strong>
• 과정 추상화 : 자세한 수행 과정 정의 x, 전반적인 흐름만 파악
• 데이터 추상화 : 데이터의 세부적인 속성, 용도 정의 x, 데이터 구조 대표할 수 있는 표현으로 대체
• 제어 추상화 : 이벤트 발생의 정확한 절차, 방법 정의 x, 대표할 수 있는 표현으로 대체
단계적 분해 : 하향식 설계 전략, 상위의 주요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
시스템 품질 속성<strong>(’성능’ 좋은 핸드폰으로 ‘변경’해서 ‘사기가 확보’했다.)</strong>
• 성능, 변경, 용이성, 사용성, 기능성, 가용성, 확장성, 보안
아키텍쳐 패턴(p.101)
• 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
• 표준 아키텍처
레이어 패턴
• 시스템을 계층으로 구분하여 구성하는 고전적인 방법
• ex. OSI 참조 모델
클라이언트-서버 패턴
• 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
• 컴포넌트 : 독립적인 업무 또는 기능 수행하는 실행코드 기반으로 작성된 모듈
파이프-필터 패턴
• 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
• 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생
모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
• 서브시스템을 3개의 부분으로 구조화하는 패턴
• 대화형 애플리케이션에 적합
마스터-슬레이브 패턴
• 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴퓨넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업 수행
• 마스터 컴포넌트는 모든 작업의 주체이고, 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 작업 수행해 결과 반환
• 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 활용
브로커 패턴
• 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자 연결
• 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
• 분산 환경 시스템에서 주로 활용
피어-투-피어 패턴
• 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
• 전형적인 멀티스레딩 방식 사용
이벤트-버스 패턴
• 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
블랙보드 패턴
• 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태
• 컴포넌트들은 검색을 통해 블랙보드에서원하는 데이터를 찾을 수 있음.
• 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
• 음성 인식, 차량 식별, 신호 해석 등에 주로 활용
인터프리터 패턴
• 프로그램 코드의 각 라인을 수행하는 방법 지정, 기호마다 클래스 갖도록 구성
• 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용
객체지향 분석 및 설계(p.110)
• 객체지향 분석의 방법론
• Rumbaugh(럼바우) 방법(객체 모델링 기법)
• 가장 일반적으로 사용되는 방법, 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법
• 객체 모델링 → 동적 모델링 → 기능 모델링
Booch(부치) 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산 정의
Jacobson 방법 : Use Case를 강조하여 사용하는 분석 방법
Coad와 Yourdon 방법 : E-R Diagram을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법
객체 지향 설계 원칙!! (SOLID 원칙) (개중요! 별표 오백사십사만개!!)
• 단일 책임 원칙(SRP, Single Responsibility Principle)
• 객체는 단 하나의 책임만 가져야 함.
• 응집도 높고, 결합도 낮게 설계
개방-폐쇄 원칙(OCP, Open-Closed Principle)
• 기존 코드 변경 하지 않고도 기능 추가할 수 있도록 설계
• 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법
리스코프 치환 원칙(LSP, Liskov Substitution Principle)
• 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
• 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야함.
인터페이스 분리 원칙(ISP, Interface Segregation Principle)
• 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 함.
• 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임
의존 역전 원칙(DIP, Dependency Inversion Principle)
• 각 객체들 간의 의존 관계가 성립될 때 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙
• 인터페이스를 활용하면 이 원칙 준수
각 모델링의 핵심
• 객체 모델링 : 객체, 클래스 추출, 객체 다이어그램
• 동적 모델링 : 시간 흐름, 상태 다이어그램
• 기능 모델링 : 자료 흐름, 자료 흐름도
디자인 패턴(P.113)
• 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 잇는 전형적인 해결 방식 또는 예제
• 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
• GoF(Gang of Four) 이라고 불리는 에릭 감마, 리차드 헬름, 랄프 존슨, 좀 블리시디가 처음으로 구체화 및 체계화함.
• 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성
아키텍처 패턴
• 디자인 패턴보다 상위 수준
• 전체 시스템의 구조를 설계하기 위한 참조 모델
디자인 패턴 장단점
• 범용적인 코딩 스타일, 구조 파악 용이
• 객체지향 설계 및 구현 생산성 높이는 데 적합
• 초기 투자 비용 부담o
• 객체지향에 적합 다른 기반의 애플리케이션에는 적합 x
생성 패턴
• 객체의 생성과 관련된 패턴 5개
• 추상 팩토리
• 구체적인 클래스에 의존 x, 인터페이스를 통해 서로 연관 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
• 연관된 서브 클래스 묶어 한 번에 교체 가능
빌더
• 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성
• 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과 만들어 낼 수 o
팩토리 메소드
• 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
• 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
• 가상 생성자 패턴이라고도 함.
프로토타입
• 원본 객체를 복제하는 방법으로 객체 생성
• 일반적인 방법으로 객체 생성, 비용이 큰 경우 주로 이용
싱글톤
• 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 x
• 클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화
구조 패턴
• 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 7개의 패턴
• 어댑터
• 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
• 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용
브리지
• 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
• 기능, 구현 두개의 별도 클래스 구현
컴포지트
• 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
• 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능
데코레이터
• 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
• 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식
퍼싸드
• 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구상함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
• 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요
프록시
• 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
• 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용
행위 패턴
• 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 11개의 패턴
• 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와줌.
• 책임 연쇄
• 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
• 요청을 처리할 수 있는 각 개체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 다라 책임이 넘어감.
커맨드
• 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
• 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 구분하여 단순화함.
• 추상 클래스 : 구체 클래스에서 구현하려는 기능들의 공통점만을 모아 추상화한 클래스, 인스턴스 생성이 불가능하여 구체 클래스가 추상 클래스를 상속받아 구체화한 후 구체 클래스의 인스턴스를 생성하는 방식으로 사용
• 구체 클래스 : 인스턴스 생성이 가능한 일반적인 클래스
인터프리터
• 언어에 문법 표현을 정의하는 패턴
• SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
• 원시 언어의 명령을 번역 실행하는 프로그램
반복자
• 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
• 내부 표현 방법의 노출 없이 순차적인 접근 가능
중재자
• 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
• 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음.
• 객체 간의 통제와 지시의 역할 수행
메멘토
• 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
옵서버
• 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
• 주로 분산된 시스템 간에 이벤트를 생성 발행하고, 이를 수신해야할 때 사용
상태
• 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
• 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
전략
• 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의
• 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능
템플릿 메소드
• 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
• 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌.
방문자
• 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
• 분리된 처리 기능은 각 클래스를 방문하여 수행</p>